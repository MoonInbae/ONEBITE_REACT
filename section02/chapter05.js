// 원시타입 => 메모리에 값이 저장됨.
// 값 수정 시에는 기존의 값은 메모리 공간에 남겨두고 변경하고자 하는 값을 새로 메모리 공간에 저장하고 변수가 가리키는 주소를 바꿈.
// => 불변값임.
let p1 = 1;
let p2 = p1;

// 객체타입 => 메모리에 값을 저장하고 변수에는 객체값이 저장된 메모리공간을 나타내는 주소값인 참조값을 저장함.
// 객체타입은 크기가 늘어났다가 줄어들었다가 하기 때문에 이런 방식을 사용함.
let o1 = { name: '문인배' };
let o2 = o1; // 같은 참조값을 가지게 됨.
o2.name = '홍길동'; // 원본 데이터를 수정하기 때문에 같은 참조값을 가지는 o1과 o2의 값 모두 바뀌게 됨. 가변값이라고도 함.
// (얕은 복사; shallow copy)
// 값이 따로 수정되게 하려면 깊은 복사; deep copy를 사용해야함.

// (깊은 복사; deep copy)의 방법은 스프레드 연산자(...) 사용하는 것.
let o3 = { name: '문인배' };
let o4 = { ...o3 };
o4.name = '홍길동';

let o5 = { name: '문인배' };
let o6 = o5;
let o7 = { ...o5 };

// 얕은 비교(참조값을 기준으로 비교)
console.log(o5 === o6); // 얕은 복사로 인한 같은 참조값으로 true출력
console.log(o5 === o7); // 깊은 복사로 구조는 같지만 다른 참조값으로 false출력

// 그렇다면 어떻게 구조가 같은지 비교하는가? => JSON.stringify 사용
// JSON.stringify이란 자바스크립트 내장 함수로 객체를 문자열로 변환하는 기능
console.log(
    // 깊은 비교(객체를 문자열로 변환하여 프로퍼티 값을 기준으로 비교)
    JSON.stringify(o5) === JSON.stringify(o7) // 문자열로 변환하여 비교하기 때문에 true 반환
);

// 마지막으로 Array과 Function도 객체 타입이다.(프로퍼티, 메서드를 가질 수 있다.)
